# -*- coding: utf-8 -*-
"""dllab2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tKsQVa7thZd0eNmdZyMdTg3JIm2DaTxh
"""

#model = models.sequential([
"""layers.Dense(16,activation = 'relu',input_shape=(4,))
multilayer perceptron
no of layers,neurons wont change
weights,bias change
summation of confusion matrix - test datas
batchsize - no of iterations
1 epoch - 15 iterations , if train data = 120 and test = 30 for epoch 50
average of error
peak - smooth when averaging
performace metrics - test data
if the samples r correctly predicted - overfitting"""

#importing Python library
import numpy as np

#define Unit Step Function (instead of signmoid function)
def unitStep(v):
  if v>=0:
    return  1
  else:
    return 0
#design perceptron model
def perceptronmodel(x,w,b):
  v = np.dot(w,x)+b #(input weight +bias)
  y = unitStep(v)
  return y

#AND LOGIC
#w1 = 1,w2 = 1, b = -1.5
def AND_logicfunction(x):
  w = np.array([1,1])
  b = -1.5
  return perceptronmodel(x,w,b)

#testing the perceptron model
test1 = np.array([0,1])
test2 = np.array([1,1])
test3 = np.array([0,0])
test4 = np.array([1,0])
print("AND({} {}) ={}".format(0,1,AND_logicfunction(test1)))
print("AND({} {}) ={}".format(1,1,AND_logicfunction(test2)))
print("AND({} {}) ={}".format(0,0,AND_logicfunction(test3)))
print("AND({} {})={}".format(1,0,AND_logicfunction(test4)))

#OR LOGIC
# w1 = 1 ,w2 = 1,w3= -0.5
def OR_logicfunction(x):
  w = np.array([1,1])
  b = -0.5
  return perceptronmodel(x,w,b)
  #testing the perceptron model (NO NEED WRITE THE TEST AGAIN , AS IT IS CALLING IN THE FIRST FUNCTION)
test1 = np.array([0,1])
test2 = np.array([1,1])
test3 = np.array([0,0])
test4 = np.array([1,0])
print("OR({} {}) ={}".format(0,1,OR_logicfunction(test1)))
print("OR({} {}) ={}".format(1,1,OR_logicfunction(test2)))
print("OR({} {}) ={}".format(0,0,OR_logicfunction(test3)))
print("OR({} {})={}".format(1,0,OR_logicfunction(test4)))

#NOT LOGIC
#wnot = -1 bNOT = 0.5
def Not_logicfunction(x):
  #w = np.array([1])
  wNOT = -1
  b = 0.5
  return perceptronmodel(x,wNOT,b)
print("NOT({})={}".format(0,Not_logicfunction(0)))

#nor
#with or and not
#function calls in sequence
def NOR_logicfunction(x):
  y1 = OR_logicfunction(x)
  y2 = Not_logicfunction(y1)
  return y2
print("NOR({} {}) ={}".format(0,1,NOR_logicfunction(test1)))
print("NOR({} {}) ={}".format(1,1,NOR_logicfunction(test2)))
print("NOR({} {}) ={}".format(0,0,NOR_logicfunction(test3)))
print("NOR({} {})={}".format(1,0,NOR_logicfunction(test4)))

#xor
#with and or and not
def XOR_logicfunction(x):
  y1 = AND_logicfunction(x)
  y2 = OR_logicfunction(x)
  y3 = Not_logicfunction(y1)
  y4 = np.array([y2,y3])
  y5 = AND_logicfunction(y4)
  return y5
print("XOR({} {}) ={}".format(0,1,XOR_logicfunction(test1)))
print("XOR({} {}) ={}".format(1,1,XOR_logicfunction(test2)))
print("XOR({} {}) ={}".format(0,0,XOR_logicfunction(test3)))
print("XOR({} {})={}".format(1,0,XOR_logicfunction(test4)))

#NAND LOGIC
# W1 = -1 , W2 = -1, B = 1.5
def NAND_logicfunction(x):
  w = np.array([-1,-1])
  b = 1.5
  return perceptronmodel(x,w,b)

print("NAND({} {}) ={}".format(0,1,NAND_logicfunction(test1)))
print("NAND({} {}) ={}".format(1,1,NAND_logicfunction(test2)))
print("NAND({} {}) ={}".format(0,0,NAND_logicfunction(test3)))
print("NAND({} {})={}".format(1,0,NAND_logicfunction(test4)))

#2BIT ADDER
#WITH AND , OR AND NOT
#FUNCTION CALLS
def half_adder_logic_function(x):
  y = NAND_logicfunction(x)
  a = np.array([x[0],y])
  y1 = NAND_logicfunction(a)
  y2 = NAND_logicfunction(np.array([x[1],y1]))
  sum = NAND_logicfunction(np.array([y1,y2]))
  carry = NAND_logicfunction(np.array([y,y]))
  return sum,carry
print("2BIT ADDER({} {}) ={}".format(0,1,half_adder_logic_function(test1)))
print("2BIT ADDER({} {}) ={}".format(1,1,half_adder_logic_function(test2)))
print("2BIT ADDER({} {}) ={}".format(0,0,half_adder_logic_function(test3)))
print("2BIT ADDER({} {}) ={}".format(1,0,half_adder_logic_function(test4)))